C++ ist weit verbreitet zur Entwicklung von Apps

Gedanken zur App-Entwicklung:
Erstens die Apps für Blinde und Sehbehinderte.
Für Menschen mit Makuladegeneration, die noch vor zwei, drei Jahren einiges mehr gesehen haben und jetzt immer mehr Unterstützung brauchen, um nicht auf's Smartphone verzichten zu müssen.
Soweit ich sehen konnte, tut sich im IOS Bereich viel mehr.
Klar muss man für solche Apps bezahlen.
Da die Zielgruppe aber ihr ganzes Leben Rechnungen bezahlt hat, ist das kein Problem, denke ich.
Der andere weiße Fleck wären Apps, die zwar schon zig mal vorhanden sind, aber nicht so.
Ich denke immer wieder daran, was passiert, wenn z.B. meine geliebte Wecker App eines Tages zu veraltet ist und nicht mehr funktioniert?
Eine ganz simple App mit Naturgeräuschen (Vogelgezwitscher, plätscherndes Wasser Seeufer, eine Sommerwiese, Regen, Bauernhof, Gong).
Der Entwickler hat die Apppflege vor drei oder vier Jahren eingestellt.


App für das Handwerk: bspw. zum Vermessen von Räumen, Möbeln, usw. ?

Eine App zur Vernetzung von Clouds, Spritpreistracking E-Ladesäulen, Tankstellen- oder Blitzer-Ortung,radiosender-App, wireshark fürs Handy? oder siehe BMW-Devel_pdf
Umfrage-App für Fahrer, die im Konvoi unterwegs sind
KommunikationsApp mit Fahrern in anderen Autos

MIcrosoft V2X Plattform, cloudcar.com

Das unter dem ITEA Call 3 geförderte, europäische Forschungsprojekt APPSTACLE befasst sich mit der Etablierung einer offenen und gleichzeitig sicheren Plattform für die Verbindung zwischen Fahrzeugen und der Cloud. ... Neben Themenstellungen wie beispielsweise Kommunikationstechnologien für die nächste Generation des Mobilfunknetzes fokussiert sich APPSTACLE sehr stark auf die Entwicklung und Verbreitung des Open Source Connected Vehicle Software Ökosystems.

Um die Entwicklung dieses Ökosystems zu institutionalisieren und zu fördern wurde aus APPSTACLE heraus das Open Source Projekt Kuksa unter dem Dach der Eclipse Foundation gegründet.

Die Eclipse Kuksa In-Vehicle Plattform baut auf Automotive Grade Linux (AGL) auf, einem offenen Linux-Derivat für die Automobilwelt.
( https://github.com/eclipse/kuksa.invehicle/tree/master/agl-kuksa -  Therefore, this projects provides a building system that adds Kuksa's specific Bitbake layers on top of the original AGL. The scripts in this project help ease the process of building an AGL image by simple using a few commands. This project includes the yocto recipes found in meta-kuksa project.)
Auf Basis dieses Betriebssystems entsteht eine Laufzeitumgebung in der Kommunikationsdienste die Verbindung zur Cloud bereitstellen aber auch Zugriff zu den Fahrzeug-internen Systemen und Daten auf einem hohen Abstraktionsniveau ermöglicht wird....Darüber hinaus erweitert Eclipse Kuksa die von AGL bereitgestellte Applikations-Laufzeitumgebung. Zu diesen Erweiterungen gehören beispielsweise maßgeschneiderte Apps für die Kuksa-Umgebung, aber auch Elemente wie Intrusion-Detection-, oder Device-Management-Komponenten zum Herunterladen, Installieren und Verwalten von Anwendungen (Apps).


Die Eclipse Kuksa Cloud-Plattform hat sich zum Ziel gesetzt eine möglichst flexible und leistungsfähige Laufzeitumgebung für die Cloud zu schaffen. Hierzu nutzt und integriert Eclipse Kuksa zahlreiche existierende Open Source Komponenten, vorzugsweise aus der Eclipse IoT Welt. Hierzu gehört beispielsweise Eclipse HONO, welches den einheitlichen Zugang zu allen angebotenen Diensten und Ressourcen ermöglicht.

Im Bereich des Device Managements setzt Eclipse Kuksa auf das Open Source Software Roll-Out System Eclipse hawkBit. Dieses ermöglicht die Verwaltung von Softwareständen der In-Vehicle-Plattform selbst sowie das Installations- und Updatemanagement von Apps. Daran angeschlossen ist ein in Eclipse Kuksa entwickelter App-Store (siehe Bild 5), welcher dem Besitzer eines Fahrzeugs ermöglicht Apps auszuwählen und seinem Fahrzeug zuzuweisen.

Die Eclipse Kuksa IDE dient der einfacheren Entwicklung von Apps für die In-Vehicle sowie Cloud-Plattform. Hierzu beschreibt die Eclipse Che Cloud IDE die Basis und ermöglicht die Bereitstellung der IDE ohne dass der Nutzer diese auf einem lokalen Rechner installieren muss.

Die Kuksa IDE ist Docker-basiert und erlaubt sowohl private als auch geteilte Workspaces. 


---> auf wiki.automotivlinux.org gibt es alles zum Thema embedded linux/yocto/App-Entwicklung usw. 
---> jaxenter.de kuksa , Artikel der gute Übersicht über AGL und kuksa liefert



14.09.:

https://docs.automotivelinux.org/docs/en/guppy/getting_started/reference/getting-started/getting-started-welcome.html

What is AGL:
Automotive Grade Linux is a collaborative, open source project that brings together automakers, suppliers, and technology companies for the purpose of building Linux-based, open source software platforms for automotive applications that can serve as de facto industry standards.
AGL address all software in the vehicle: infotainment, instrument cluster, heads-up-display (HUD), telematics, connected car, advanced driver assistance systems (ADAS), functional safety, and autonomous driving.


durchlesen des Build-Prozesses von AGL:
1.) AGL-Images basieren auf yocto, man kann vorgefertige Images für verschiedene Boards( Raspi 2,3 etc.) und QucikEmulator QEmu downloaden.
Falls kein native Unix sondern eine VM zum Einsatz kommt, kann man sich einen Docker-Container downloaden in dem die Build-Umgebung eingereichtet ist.
(benötigter Speicher mind. 50GB)

2.) AGL Software und Soruce-Code zum Builden mit bitbake vom gerrit-server downloaden und ausführen

3+4.) das Steup-Skript aglsetup.sh über aufgelistete features (pentesting, TFTP-Boot, debugging-tools usw.) auf meine Wünsche zuschneiden.
Das Skript erzeugt zwei primäre Konfigurationdateien bblayer.conf und local.conf und legt sie im conf-Ordner ab. Mit local.conf customizen zB download-Ordner, tmp_dir festlegen usw.

5.) Running bitbake mit build-target, das target kann Raspi 3/4, Emulator (QEMU,VirtualBox) o.Ä. sein. Ratsam ist es die vorgefertigten Images zu verwenden.


Overview Homescreen: 
Startbildschirm nach Booten des AGL-Images mit Screenshots von Demo-Apps, Maps für die Navigation-App müssen extra installiert werden.


setting up docker (confer to cloud-project):
The container you set up here is configured for Yocto Project and AGL. This configuration means you do not have to have a native Linux build host. You can also use a system running Microsoft or MacOS.
set up a workspace according to the instructions of the website.
You can build a docker-image on your own or download a pre-built docker image. Docker engine converts image into container and run it.
Once you have a new container that is based on the AGL Worker Image, you can copy the SDK Installer to the container and then install the target-specific AGL SDK. 
With an SDK installed, you are able to develop AGL applications using the SDK.


Developing an application:
Steps: 
1.) Download or build the image you are going to run on the hardware device.
2.) Download or build the Software Development Kit (SDK) you use to create your application.
3.) Create bootable media using your image.
4.) Boot your hardware device with the media.
5.) Prepare your environment so that you can develop an application. You can develop the application using XDS or using a stand-alone SDK.
6.) Create your application.
7.) Deploy the application to your hardware with either SDCard, nfs, SSH etc.
8.) Debug the application using gdb and/or core-dumps

zu 2.) 
The Software Development Kit (SDK) allows you to use your build host to develop an application specific to your target hardware. SDKs are installed onto your build host by running an SDK installer file (*.sh). If you are developing an application for a board supported by the AGL software, you might want to just download a pre-built SDK installer file otherwise you need to build the SDK installer file.

zu 5.)
You can use the X(cross) Development System (XDS), or you can use a stand-alone Software Development Kit (SDK). The preferred method is to use XDS.
To use XDS, you need to install server and client parts and then use XDS to install the SDK. 
--> refer to:  https://docs.automotivelinux.org/docs/en/guppy/devguides/reference/xds/part-1/client-part.html


15.09.:
---- Developers guide ----

https://docs.automotivelinux.org/docs/en/guppy/devguides/agl-layers-overview.html
AGL uses layers designed to be compatible with the Yocto Project and the OpenEmbedded Project (OE).
Three important layers: 
met-agl ( Minimal set of software needed to create an AGL distribution used to boot a system. AGL profiles are built on top of this minimal set of software)
meta-agl-demo (Provides a reference or demo platform and applications for the AGL Distribution) 
meta-agl-devel (Contains components under development or being tested )

Many many sublayers with a bunch of features provided, too many to go into detail, but important is the meta-hmi-framework layer for infotainment.



----Microservices-----
You can develop Microservices on your native Linux machine quickly by taking advantage of RPM or Debian packages. The following figure and list overview the Microservice Native Development process.

1.) Verify your build host (Make sure you have a native Linux host. --> maybe Container possible?)
2.) Download and Install AGL Packages (Download and install the near-zero packages from the OBS)
3.) Install Binder Daemon (The daemon allows you to connect applications to required services and is part of the AGL Application Framework (AFM))
4.) Get your source files (Clone the helloworld-service binding repository. You also need to make sure you have some other required packages to build that specific binding)
5.) Build and run your service natively (Build and test your binding on your Linux host using native tools. if succesful optional tools can be brought in)

zu 3.)
The Application Framework Binder Daemon (afb-daemon), which is a part of the AGL Application Framework, provides a way to connect applications to required services.

---> microservice test in agl_microservices ausprobieren,
https://docs.automotivelinux.org/docs/en/guppy/devguides/reference/5-building-and-running-service-natively.html
installed packages libjson-c-dev, cfg-pkg

to do:  erstmal mehr über Microservices lernen


25.11.
Docker-container für AGL-build-umgebung downloaden (50GB Speicher benötigt)
refer to: https://github.com/automotive-grade-linux/docs-agl/blob/master/docs/getting-started/setup-sdk-environment.md

statt ~/devel verwende ich ~/Schreibtisch/agl_microservice/build, aber ich habe einen Softlinks erstellt von devel und ssd

ABER:
Ich versuche die Build-Umgebung selbst aufzubauen, hilft dann später sicher auch beim Verständnis.

AGL-Account: Username: roland089 PW: Muenchen_089

Info:
Yocto is a set of tools, templates and methods for building Linux systems from scratch. Automotive Grade Linux is a complete Linux distribution designed for in-car systems. 
It includes base system layers from Poky and OpenEmbedded, board support layers for popular automotive platforms, and quite a lot more.
All of these layers are assembled into a built Linux system by Bitbake, the build tool of the Yocto Project, based on the instructions in the recipes inside the layers.


29.11.:
Die IDE für das App-Developing nennt sich Kuksa App IDE und baut auf eclipse CHE auf. 
Eclipse CHE ist eine Brwoseranwendung, die Zugang zu einem Container ermöglicht, innerhalb dem man Apps builden kann. 
Das gesamte Auto-Betriebssystem ist AGL, und auf dieser Basis läuft über den AppStore/HawkBit dann die App. 
Es gibt auch Docker-Images zu AGL, brauch ich diese zum Build in CHE ?

https://www.eclipse.org/kuksa/documentation/

Download von maven: version: 
Apache Maven 3.6.0
Maven home: /usr/share/maven
Java version: 11.0.9.1, vendor: Ubuntu, runtime: /usr/lib/jvm/java-11-openjdk-amd64
Default locale: de_DE, platform encoding: UTF-8
OS name: "linux", version: "4.15.0-123-generic", arch: "amd64", family: "unix"

Versuch Container zu starten mit: 
sudo docker run -ti -v ~/.m2:/home/user/.m2 -v `pwd`:/home/user/che-build -v `pwd`:/projects eclipse/che-dev:6.10.0 sh -c "mvn -e clean install"
 -t, --tty                            Allocate a pseudo-TTY
  -i, --interactive                    Keep STDIN open even if not attached
  -v, --volume list                    Bind mount a volume

das Ausführen mit sudo docker run -ti -v ~/.m2:/home/user/.m2 -v `pwd`:/home/user/che-build -v `pwd`:/projects eclipse/che-dev:6.10.0 klappt --> fehler bei marven ?!
--> mit sudo sh -c "mvn -e clean install" ein Schritt weiter, jetzt Fehler fehlendes Projekt/falscher Ordner

bloß mit pull: image gespeicher unter var/lib/docker/overlay2

for AGL-image: https://agl-docs.readthedocs.io/en/master/#0_Getting_Started/2_Building_AGL_Image/0_Build_Process/

AGL Webinar am 1.12.
buy UART to USB-cable for booting stage of raspi very recommended form cli output
western/wayland for graphica ouput/ compositor
systemd-log and western-log file needed for booting on new hardware
latest stable relaese: dunfell from April 2020
meta-rapsberrypI add layer bb.conf to project, agl should work out of box

check hira.automotivelinux.org/brwose/SPEC-2465


best used Raspi 4b wtih 4GB or 8GB RAM 


prebuilt Kernel for Qemu: https://download.automotivelinux.org/AGL/snapshots/master/latest/qemux86-64/deploy/images/qemux86-64/bzImage
prebuilt image for qemu: https://download.automotivelinux.org/AGL/snapshots/master/latest/qemux86-64/deploy/images/qemux86-64/agl-demo-platform-crosssdk-qemux86-64.ext4.xz



aus: https://raw.githubusercontent.com/automotive-grade-linux/docs-sources/guppy/docs/app-framework/index.md
oder zum read-only: https://github.com/automotive-grade-linux/docs-agl/blob/master/docs/app-framework/index.md
(evtl andere Seiten im Archiv enthalten? )

app development: # AGL Application Framework

This page summarizes all materials related to AGL Application Framework

## Source Code

The current code of AGL App-Framework is stored on AGL Code Repository. It's divided in the following projects:

* [src/app-framework-main](https://gerrit.automotivelinux.org/gerrit/gitweb?p=src%2Fapp-framework-main.git;a=summary) Main services
* [src/app-framework-binder](https://gerrit.automotivelinux.org/gerrit/gitweb?p=src%2Fapp-framework-binder.git;a=summary): Binder Daemon
* [src/app-framework-demo](https://gerrit.automotivelinux.org/gerrit/gitweb?p=src%2Fapp-framework-demo.git;a=summary) Demos

## Building AGL with Application Framework support

The Application Framework can be added easily to an AGL build using the feature 'agl-appfw-smack'.

Typically, the following command can be called to initialize AGL build:

    # meta-agl/scripts/aglsetup.sh -m porter agl-appfw-smack agl-demo agl-devel
    ...
    # bitbake agl-demo-platform

## Documentation

Technical documentation is maintained in the source code and should be browsable with the [upcoming AGL documentation system](https://github.com/automotive-grade-linux/docs-agl)

Temporarily, a static documentation has been made in PDF format:

* [Introduction to Application Framework](http://iot.bzh/download/public/2016/appfw/01_Introduction-to-AppFW-for-AGL-1.0.pdf)
* [AppFW Core Documentation](http://iot.bzh/download/public/2016/appfw/02_Documentation-AppFW-Core-2.0.pdf)
* [Privileges Management](http://iot.bzh/download/public/2016/appfw/03-AGL-AppFW-Privileges-Management.pdf)

Some extra guides are also available in PDF format:

* [Build your 1st AGL Application](http://iot.bzh/download/public/2016/sdk/AGL-Devkit-Build-your-1st-AGL-Application.pdf)
* Applications Templates are available on [github:iotbzh/app-framework-templates](https://github.com/iotbzh/app-framework-templates)

### Bindings Examples

Some bindings are  available to quickstart new projects:

* GPS - see [github:iotbzh/af-gps-binding](https://github.com/iotbzh/af-gps-binding/blob/master/src/af-gps-binding.c)
* OpenXC Reader - see [github:iotbzh/txc-demo](https://github.com/iotbzh/txc-demo/blob/master/binding/txc-binding.c)
* CPU/Memory stats - see [github:iotbzh/txc-demo](https://github.com/iotbzh/txc-demo/blob/master/binding/stat-binding.c)
* Radio - see [gerrit:src/app-framework-binder](https://gerrit.automotivelinux.org/gerrit/gitweb?p=src/app-framework-binder.git;a=tree;f=bindings/radio;hb=master)
* Audio - see [gerrit:src/app-framework-binder](https://gerrit.automotivelinux.org/gerrit/gitweb?p=src/app-framework-binder.git;a=tree;f=bindings/audio;hb=master)

The list is not exhaustive. ***Please add other bindings here !***

### Demos

* Simple HTML5 Demos apps (ported from Tizen) on [github:iotbzh/afm-widget-examples](https://github.com/iotbzh/afm-widget-examples)
* Installable package with [TXC Demo Application](http://iot.bzh/download/public/2016/afb-demos/txc-demo_0.1.wgt)
* Applications available in [gerrit:app-framework-demo](https://gerrit.automotivelinux.org/gerrit/gitweb?p=src/app-framework-demo.git;a=summary)

## Presentations

* Oct 16 - [Application Security Model - Status Update](http://iot.bzh/download/public/2016/genivi/CyberSecurity-Genivi-Q42016-Fulup-IoTbzh.pdf)
* Sept 16 - [Building Applications with AGL Framework](http://iot.bzh/download/public/2016/genivi/CyberSecurity-Genivi-Q42016-Fulup-IoTbzh.pdf) - Also visible in [PDF version](http://iot.bzh/download/public/2016/publications/build-agl-application-AMM-Munich-2016.pdf)
* Feb 16 - [HTML5 Apps for Automotive Systems](http://iot.bzh/download/public/2016/publications/HTML5_Applications_for_Automotive_Systems.pdf)
* Feb 16 - [Application & Security Framework Proposal AGL 2.0](http://iot.bzh/download/public/2016/security/Security-Proposal-AGL20-Fulup.pdf)
* Jan 16 - [Security Architecture Proposal](http://iot.bzh/download/public/2016/security/Security-Architecture-AGL20.pdf)

## History

### Motivation for rewriting the App. Framework

To get the background and motivation on why Application Framework has been rewritten:

* [Tizen Security: lessons learnt](http://iot.bzh/download/public/2015/tizen-security-lessons-learnt-initial.pdf)
* [this discussion](https://lists.linuxfoundation.org/pipermail/automotive-discussions/2016-October/002749.html)
* [Linux Automotive Security](http://iot.bzh/download/public/2016/security/Linux-Automotive-Security-v10.pdf)

### Comparison/Relationship with Tizen

                              Tizen           AGL
                              ----------------------------------
    App/OS isolation           yes            yes
    Container option           no             possible
    Native App                 partial*       yes
    HTML5 App                  yes            yes
    Cloud App                  No             yes
    Unified API (HTLM/Native)  No             yes
    service as App**           No             yes
    Adding API    ***          core           core or App
    Devel model                bespoke        Standard Web




1.12.:
https://docs.huihoo.com/automotivelinux/docs/getting_started/en/dev/reference/setup-sdk-environment.html


This tutorial explains how to quickly setup an environment suitable to building and packaging AGL Applications using the SDK and a Docker container. The current tutorial has been tested on Linux, but may work with a few adjustments for Windows or MacOS.
1.step: First install docker on your host, if not already done. General instructions for Linux are available on the Docker Site.

2.step: setup persistent workspace: Docker images are pre-configured to use a particular uid:gid to enable the use of OpenEmbedded build system. They provide a dedicated user account devel which belong to uid=1664(devel) gid=1664(devel). (Note: password is devel)

The script ‘create_container’ presented below instantiates a new container and shares some volumes with the host:

    /xdt (the build directory inside the container) is stored in ~/ssd/xdt_$ID (specific to instance ID)
    /home/devel/mirror is stored in ~/ssd/localmirror_$ID (specific to instance ID)
    /home/devel/share => points to ~/devel/docker/share (shared by all containers)

Those shared volumes with the host needs the proper permissions to be accessible from the contained environment.

mkdir ~/ssd ~/devel
chmod a+w ~/ssd ~/devel

Note:
To gain access from your host on files created within the container, your host account requires to be added to group id 1664.


Step 3: install the “Generic AGL Worker” Docker Image: 

A pre-built image is available on automotivelinux download public site and can be used directly.
First, download and load the image in your local Docker instance:

"$ wget -O - https://download.automotivelinux.org/AGL/snapshots/sdk/docker/docker_agl_worker-3.0.tar.xz | sudo docker load; sudo docker images;"
      REPOSITORY                              TAG                 IMAGE ID            CREATED             SIZE
      docker.automotivelinux.org/agl/worker   3.0                 42009148bc03        6 days ago          926.9 MB
      jenkins                                 latest              55720d63e328        5 weeks ago         711.9 MB
      hello-world                             latest              c54a2cc56cbb        5 months ago        1.848 kB

( Rebuilt image:  The Docker image for AGL Worker can be rebuilt using the scripts published here docker-worker-generator.)
Start image: Then, use the ‘create_container’ script to start a new, fresh container based on the AGL Worker image:

Note:

    The password for the id ‘devel’ inside the docker image is ‘devel’.

git clone https://git.automotivelinux.org/AGL/docker-worker-generator;
cd docker-worker-generator;
./contrib/create_container 0;
docker ps;
    CONTAINER ID        IMAGE                                       COMMAND                  CREATED             STATUS              PORTS                                                                                        NAMES
    4fb7c550ad75        docker.automotivelinux.org/agl/worker:3.0   "/usr/bin/wait_for_ne"   33 hours ago        Up 33 hours         0.0.0.0:222


Step 4: install the AGL SDK for your target: 
Here, we assume that we just built an image ‘agl-demo-platform-crosssdk’ using the Yocto build procedure documented in the Getting Started section of the documentation.
So we can copy such file to the shared volume. (shared volume like vol_tmp in database)

For example, we could have built the SDK from another worker container listening with SSH on port 2223:

create_container 1;
ssh -p 2223 devel@mybuilder.local;
... [ prepare build environment ] ...
bitbake agl-demo-platform-crosssdk;
... [ build happens in /xdt/build ] ...
cp /xdt/build/tmp/deploy/sdk/poky-agl-glibc-x86_64-agl-demo-platform-crosssdk-cortexa15hf-neon-toolchain-3.0.0+snapshot.sh ~/share;

then login to the first “SDK Container” and install the SDK:

ssh -p 2222 devel@mysdk.local;
install_sdk ~/share/poky-agl-glibc-x86_64-agl-demo-platform-crosssdk-cortexa15hf-neon-toolchain-3.0.0+snapshot.sh;

Step 5: build your application:

First, you must source the SDK environment you wish to use (you MUST repeat this step each time you open a new shell):
source /xdt/sdk/environment-setup-<your_target>

You’re then ready to go: get the sources, run the builds …

git clone <your repo for your app>;
cd <your app>;
cmake; make; make package;



source for application-devel-sw: https://gerrit.automotivelinux.org/gerrit/gitweb?p=src%2Fapp-framework-main.git;a=summary

< aktuell sind auf der Maschine noch 71 GB frei sagt "df -H" >

3.12.
app development laut https://agl-docs.readthedocs.io/en/master-ivory/0_Getting_Started/6_%20Developing_an_Application%20/5_Get_Ready_to_Create_Your_Application/

1.) Download or build the image you are going to run on the hardware device and 2.) download or build the Software Development Kit (SDK) you use to create your application.
3.) Create bootable media using your image. 4.) Boot your hardware device with the media.
5.) Prepare your environment so that you can develop an application. You can develop the application using XDS or using a stand-alone SDK.
6.) Create your application and 7.) Deploy the application to your hardware and at last 8.) Debug the application if necessary.

for 
1.)	https://agl-docs.readthedocs.io/en/master-ivory/0_Getting_Started/6_%20Developing_an_Application%20/1_Download_or_Build_Your_Image/
You can either build that image from scratch or, if you are going to use hardware supported by AGL, you can download a ready-made image from the AGL Download Website site.
For example Quick EMUlator (QEMU): QEMU is a generic, open source machine emulator and virtualizer. You can use QEMU as your "hardware" when you run an image built for the emulator. AGL supports QEMU images for ARM 32/64bit and Intel 64bit devices.
As an example, suppose you want to download the 64-bit ARM-based image that you can emulate using QEMU. Go to the AGL Download Website (https://download.automotivelinux.org/AGL/release/) and follow these links:
icefish -> 9.0.0 -> qemuarm64 -> deploy -> images -> qemuarm64 ; From the list, you could download the Image-qemuarm64.bin Kernel and the agl-demo-platform-crosssdk-qemuarm64.ext4.xzImage file.


2.) https://agl-docs.readthedocs.io/en/master-ivory/0_Getting_Started/6_%20Developing_an_Application%20/2_Download_or_Build_Your_SDK_Installer/
The Software Development Kit (SDK) allows you to use your build host to develop an application specific to your target hardware. SDKs are installed onto your build host by running an SDK installer file (*.sh).
You must either download a pre-built installer file for your SDK or build an installer file. If you are developing an application for a board supported by the AGL software, you might want to just download a pre-built SDK installer file. If your hardware is not supported by AGL, you need to build the SDK installer file with "bitbake agl-demo-platform-crosssdk" and targetboard specifics.
The SDK installer file (*.sh) is placed in the build directory. Assuming your top-level workspace is ~/workspace_agl, here is an example location and SDK installer file:
~/workspace_agl/build/tmp/deploy/sdk/poky-agl-glibc-x86_64-agl-demo-platform-crosssdk-aarch64-toolchain-8.0.0.sh

For a look at the SDK installers for supported boards, go to the AGL Download Website. From there, you can explore to find the SDK installer you want to download. As an example, consider using a pre-built SDK to develop applications suited for a 64-bit ARM-based board that you want to emulate using QEMU. Furthermore, you are using the 8.0.0 "Halibut" release of the AGL software. Follow these links:
halibut -> 8.0.0 -> qemuarm64 -> deploy -> sdk
From the list, you download the *.sh file, which is an installation script for the SDK. Running the SDK installer script installs the SDK onto your build host.
SDK installation scripts have long names that reflect the platform specifics. For example, the following file installs the SDK given the specifics earlier:
poky-agl-glibc-x86_64-agl-demo-platform-crosssdk-aarch64-toolchain-8.0.0.sh


3.) 
In order to test an application, your device must be running the image and, of course, the application. To run the image, you need to create a bootable image that can be launched from an external device such as an SD card or USB stick.
The following list overviews the process. 1.)Insert your media into the appropriate build host interface (e.g. USB port). 2.)Determine the device name of your portable media (e.g. sdb).
3.) Write out the image using e.g. etcher , bmaptool or dd.
For example: "Deploying the AGL Demo Image" for emulation images, 
"Booting the Image on Raspberry Pi for Raspberry Pi 4 board

4.)	https://agl-docs.readthedocs.io/en/master-ivory/0_Getting_Started/6_%20Developing_an_Application%20/4_Boot_the_Image_on_the_Board/

You must have your image booted and running on your target device at some point before deploying your application for testing.
Steps exist for booting the following devices:
    Intel Devices: See the "Booting the Image on the Target Device" section.
    QEMU: See the "Deploying the AGL Demo Image" section.
    R Car Starter Kit: See the "Booting the Image Using a MicroSD Card" section.
    Raspberry PI: See the "Booting the Image on Raspberry Pi" section.


5.)	https://agl-docs.readthedocs.io/en/master-ivory/0_Getting_Started/6_%20Developing_an_Application%20/5_Get_Ready_to_Create_Your_Application/
Multiple methods exist that allow you to create your application. You can use the X(cross) Development System (XDS), or you can use a stand-alone Software Development Kit (SDK). The preferred method is to use XDS which allows you to build, deploy, and execute personal projects on a target either through the XDS dashboard or the XDS command line.
If you do not want to use XDS, you can install the SDK by itself. For information, see the "App development SDK for Intel Minnowboard" Wiki article. You can also visit the Yocto Project Application Development and the Extensible Software Development Kit (eSDK) Manual.
---- !!! NOTE: The AGL Project is not compatible with the eSDK. You must use the Standard SDK !!!! ---

6.)	https://agl-docs.readthedocs.io/en/master-ivory/0_Getting_Started/6_%20Developing_an_Application%20/6_Create_and_Build_the_Application/
A simple application you can experiment with is the standard "hello world" application. For information on how to get set up and then clone the Git repository for the "Hello World" application, see the "Get the Source Files" section.
Key to developing an application suited for your target hardware is the Standard Software Development Kit (SDK).You can develop your application a number of ways. The following list describes several:
Build the Application Using a Stand-Alone SDK: Nothing prevents you from using a Standard SDK completely outside of the AGL Project development environment to build your application. Here are a couple of methods:

Install Docker and create a container that has your SDK installed. The container is a stable environment where you can build applications. See the "Setting Up a Docker Container" section for information on how to install Docker and create a container that has your SDK installed.

Use the popular Eclipse IDE configured to work with the Yocto Project. See the "Developing Applications Using Eclipse" section in the Yocto Project Application Development and Extensible Software Development Kit (eSDK) Manual.

Using Qt Creator / qmake and want to use the same .pro / .pri file to build for desktop or AGL? Put AGL-specific definitions inside a linux-oe-* block in your .pro and .pri files, e.g.: ``` linux-oe-* { PKGCONFIG += qlibwindowmanager qtappfw DEFINES += AGL QMAKE_LFLAGS += "-Wl,--hash-style=gnu -Wl,--as-needed" load(configure) qtCompileTest(libhomescreen)

 config_libhomescreen {
     CONFIG += link_pkgconfig
     PKGCONFIG += homescreen
     DEFINES += HAVE_LIBHOMESCREEN
 }

 DESTDIR = $${OUT_PWD}/../package/root/bin

} ```


7.) 	https://agl-docs.readthedocs.io/en/master-ivory/0_Getting_Started/6_%20Developing_an_Application%20/7_Deploy_the_Application_to_the_Board/
Many options exist for controlling your target and copying your compiled application to the target. Details are target-specific and cannot be explained in detail here.
Suffice it to say that if you compile your application on your build host and you have an image running on your target hardware, you must employ some method to copy the application to the target. Several general methods exist:
    Write the application to a storage device that both the build host and the target hardware support. This could be an SD card or a flash drive. Be sure to format the drive as FAT32 to eliminate file ownership and permission issues.

    Remotely mount the target's file system on the build host with the Network File System (NFS) or Samba.
    Commit compiled code from the build host to a shared repository and update the target from that repository.
    Use remote commands from a host over a network, such as scp (i.e. secure copy).
    You can set up your build environment to leverage a procedure's application template (app-template). An app-template is an application framework that contains CMake macros that abstract deploying the application. For example, with a proper build environment, you can run the following to deploy your application:
    $ make widget-target-install

    NOTE: The previous command uses scp to copy and install the widget to a pre-defined target board.

Once you have the application copied to the target, it must provide a way to initiate operating system commands. To initiate operating system commands, you can do one of the following:
    Connect a keyboard and display directly to the target.
    Use ssh from a network-connected host to run commands on the target remotely.
    Use a network for communication between the build host and the target. This method works nicely when the build host and the target hardware are geographically apart.


8.)	https://agl-docs.readthedocs.io/en/master-ivory/0_Getting_Started/6_%20Developing_an_Application%20/8_Debug_the_Application/	

Three methods exist:
    Use gdb on the target.
    Use Core Dumps if you have set the agl-devel feature. Core Dumps are obviously more suited for post-mortem analysis. For features, see the "Initializing Your Build Environment" topic.
	NOTE: Core Dumps are available only with the "Flunky Flounder" release (i.e. 6.x).
    Use XDS remotely, which is based on gdb and gdbserver. See the "Using the XDS Command Line" topic for more information.
In order to use third-party debugging tools, you need to include the tools in the target image. You gain access to the tools by enabling the agl-devel feature when you run the aglsetup.sh script as described in the "Initializing Your Build Environment" section.

----------important archive: https://iot.bzh/download/public/  with explanation to several topics like agl app development ---------------- 
------------   https://docs.automotivelinux.org/en/master/#0_Getting_Started/2_Building_AGL_Image/5_1_x86_Emulation_and_Hardware/ -------------



finally started testing in path ~/Schre../aglmic../build
downloaded compressed prebuilt image and kernel into this folder
command "dpkg --print-architecture" yields amd64

installed qemu and vinagre
prebuilt image extrahiert:	xz -v -d agl-demo-platform-crosssdk-qemux86-64.ext4.xz

launch qemu with vinagre:
( sleep 5 && vinagre --vnc-scale localhost ) > /tmp/vinagre.log 2>&1 & qemu-system-x86_64 -device virtio-net-pci,netdev=net0,mac=52:54:00:12:35:02 -netdev user,id=net0,hostfwd=tcp::2222-:22 -drive file=agl-demo-platform-crosssdk-qemux86-64.ext4,if=virtio,format=raw -show-cursor -usb -device usb-tablet -device virtio-rng-pci -snapshot -vga virtio -vnc :0 -soundhw hda -machine q35 -cpu kvm64 -cpu qemu64,+ssse3,+sse4.1,+sse4.2,+popcnt -enable-kvm -m 2048 -serial mon:vc -serial mon:stdio -serial null -kernel bzImage -append 'root=/dev/vda rw console=tty0 mem=2048M ip=dhcp oprofile.timer=1 console=ttyS0,115200n8 verbose fstab=no'

Fehler:
Could not access KVM kernel module: No such file or directory
qemu-system-x86_64: failed to initialize KVM: No such file or directory

---> sudo modprobe kvm-intel gives = modprobe: ERROR: could not insert 'kvm_intel': Operation not supported:  go in the BIOS and enable Virtualization.
virtualization-error: https://bbs.archlinux.org/viewtopic.php?id=187825
https://bbs.archlinux.org/viewtopic.php?id=231209

dmesg zeigt "kvm: no hardware support" ---> eine QEMU KVM innerhalb existierender VM klappt evtl nicht ?!
Erstmal application so builden und dann Gedanken machen zum Testen, PC aus Arbeit etc.
"


7.12.
das SDK installiert, jedes Mal bei verwenden muss ich es sourcen:
$ source /home/gast/Schreibtisch/agl_microservice/sdk/environment-setup-corei7-64-agl-linux

Durchlesen von https://iot.bzh/download/public/2016/sdk/AGL-Devkit-Build-your-1st-AGL-Application.pdf

wahrscheinlich meine Anwendung: 
• Hybrid application (composed of a backend and a frontend) contains at the same time (an) Application-specificBinding(s) as backend(s) and a User Interface (Native, HTML5, QML ...)as a frontend.
It allows developers to provide capabilities through Bindings, and an end-userexperience through the UI. 
For instance, a GPS Binding giving devicelocalization status, and a HTML5 GPS frontend displaying it on the screen.

An App/service-folder contains:
•CMakeLists.txt: our templates use CMake for automatic configuration andbuilding. In your projects, you can of course adapt templates to use yourpreferred solution (Autoconf, Scons...).
•gulpfile.js:these are some kind of “Makefiles” used by the Gulp tool. gulp is often used in HTML5 projects as it is able to execute all needed tasks to processweb source files (JavaScript, CSS, HTML templates, images...) and create a directory suitable for deployment on a website.
•package.json: this is a Node.js file used to specify prjoject dependencies.Basically, gulp and gulpfile.js will download and install all packages mentionedhere to assemble the HTML5 project during the “npm install” step.
•config.xml(.in): XML configuration file required by the application framework.This file is mandatory for an AGL Application to be installed and launched by theframework.
•export.map: for Bindings (a.k.a. shared libraries) only, this file must contain alist of exported API verbs. Only the symbols specified in this export file will beaccessible at runtime. So export.map should contain all verbs you intend toprovide in your Binding.

~/Schreibtisch/agl_microservice/sdk/DEPRECATED_app-framework-templates-master/templates/service/build$ cmake ..
-- Toolchain file defaulted to '/home/gast/Schreibtisch/agl_microservice/sdk/sysroots/x86_64-aglsdk-linux/usr/share/cmake/OEToolchainConfig.cmake'
-- The C compiler identification is GNU 9.3.0
-- The CXX compiler identification is GNU 9.3.0
-- Check for working C compiler: /home/gast/Schreibtisch/agl_microservice/sdk/sysroots/x86_64-aglsdk-linux/usr/bin/x86_64-agl-linux/x86_64-agl-linux-gcc
-- Check for working C compiler: /home/gast/Schreibtisch/agl_microservice/sdk/sysroots/x86_64-aglsdk-linux/usr/bin/x86_64-agl-linux/x86_64-agl-linux-gcc -- works
-- Detecting C compiler ABI info
-- Detecting C compiler ABI info - done
-- Detecting C compile features
-- Detecting C compile features - done
-- Check for working CXX compiler: /home/gast/Schreibtisch/agl_microservice/sdk/sysroots/x86_64-aglsdk-linux/usr/bin/x86_64-agl-linux/x86_64-agl-linux-g++
-- Check for working CXX compiler: /home/gast/Schreibtisch/agl_microservice/sdk/sysroots/x86_64-aglsdk-linux/usr/bin/x86_64-agl-linux/x86_64-agl-linux-g++ -- works
-- Detecting CXX compiler ABI info
-- Detecting CXX compiler ABI info - done
-- Detecting CXX compile features
-- Detecting CXX compile features - done
-- Found PkgConfig: /home/gast/Schreibtisch/agl_microservice/sdk/sysroots/x86_64-aglsdk-linux/usr/bin/pkg-config (found version "0.29.2") 
-- Checking for modules 'json-c;afb-daemon'
--   Found json-c, version 0.13.1
--   Found afb-daemon, version 10.90.0
-- Creation of xxxxxx-service for AFB-DAEMON
-- Configuring done
-- Generating done
-- Build files have been written to: /home/gast/Schreibtisch/agl_microservice/sdk/DEPRECATED_app-framework-templates-master/templates/service/build

This produced a “xxxxxx-service.wgt” package. Let us copy it to the target: scp xxxxxx-service.wgt root@$BOARDIP:~/
( analog Vorgehen für native application, html application etc.

Then log in to target-board and install widget, for example via ssh
install: afm-util install xxxxxx-service.wgt

All templates have been installed through the application framework, so we will runthem with the afm-util tool (only exception: Native application)
When the afm-user-daemon process receives a request to start an application, it reads the application's “config.xml” configuration file located in its specific directory
(/usr/share/afm/applications/<appname>/<version>/config.xml). Depending on thespecified MIME type (or the default Linux MIME type in none was given), 
it then starts(an) appropriate process(es).Final behavior is controlled by the global “/etc/afm/afm-launch.conf” config file.

Run a service: afm-util run xxxxxx-service@0.1
confirm it is running:# afm-util ps ----------- or # ps -ef | grep afb

11.12:
https://iot.bzh/download/public/2017/SDK/AppFw-Documentation-v3.1.pdf
Foreword to document:
This document describes what we intend to do. It may happen that our current implementation and the content of this document differ.In this case, this document is right, implementation is wrong.
afm-system-daemon and afm-user-daemon provide infrastructure for (un-)installing, launching, terminating, pausing and resuming applications in a multi user secure environment.
A third component exists in the framework, the binder  afb-daemon. The binder provides the easiest way to provide secured API for any tier.

< Smack (full name: Simplified Mandatory Access Control Kernel) is a Linux kernel security module that protects data and process interaction from malicious manipulation 
using a set of custom mandatory access control (MAC) rules >

Framework-Components are:
•SECURITY-MANAGER: in charge of  setting  Smack contexts  and rules,  of setting groups, and, of creating initial content of CYNARA rules for applications.
•CYNARA: in charge of handling API access permissions by users and by applications.
•D-Bus: in charge of checking security of messaging. The usual D-Bus securityrules are enhanced by CYNARA checking rules.
•afm-system-daemon: in charge of installing and uninstalling applications.
•afm-user-daemon: in charge of listing applications, querying application details, starting, terminating, pausing, resuming applications and their instances for a given user context.
•afb-binder: in charge of serving resources and features through an HTTPinterface.
•afm-main-binding: This binding allows applications to use the API of the AGL framework.

The security framework refers to the security model used to ensure security and tothe tools that are provided for implementing that model.It also includes features of reporting 
using audit features and by managinglogs and alerts.
The application framework (afw) manages the applications: (un-)installing, starting,pausing, listing. The afw uses the security model/framework to ensure the security
and the privacy of the applications that it manages.The afw must be compliant with the underlying securitymodel/framework. But it should hide it to the applications.


Security Model: https://wiki.tizen.org/Security/Tizen_3.X_Overview
In theory, the security framework/model is an implementation detail that should not impact the layers above the application framework.
The application framework on top of the security framework provides the componentsto install and uninstall applications and to run it in a secured environment.The goal is to manage applications and to hide the details of the security framework to the applications.For the reasons explained in introduction, we did not use the application framework of Tizen as is but used an adaptation of it.


Daemons  afm-user-daemon  and  afm-system-daemon  handle   applications   life. Understand that they will manage operations like:
•installation	•uninstallation	•running	•suspend	•inventory
In addition, they ensure that operations use the security framework as needed and that applications are executed in the correct context.
D-Bus is in charge of transmitting orders to the appropriate daemon depending upon D-Bus destination.

User sessions are listening with the destination name org.AGL.afm.[user|system] at the object of path /org/AGL/afm/[user|system] on the interface org.AGL.afm.[user|system] for the below detailed members for the afm-system-daemon: 	•install•uninstall
And for afm-user-daemon:	•runnables•detail•start•once•terminate•pause•resume•runners•state•install•uninstall

D-Bus is mainly used for signaling and discovery.
examples using dbus-send, here to install an application from a widget file:
dbus-send --session --print-reply --dest=org.AGL.afm.system /org/AGL/afm/system org.AGL.afm.system.install 'string:"/tmp/appli.wgt"
And here, to query data on installed applications that can be run:
dbus-send --session --print-reply --dest=org.AGL.afm.user /org/AGL/afm/user org.AGL.afm.user.runnables string:true

The D-Bus interface is defined by:
•DESTINATION: org.AGL.afm.[user|system]
•PATH: /org/AGL/afm/[user|system]
•INTERFACE: org.AGL.afm.[user|system]


16.12.
afm-system-daemon  and  afm-user-daemon  are launched as systemd services attached to system and user respectively. Normally, service files are located at 
/lib/systemd/system/afm-system-daemon.service  and /lib/systemd/user/afm-user-daemon.service

At start afm-user-daemon scans the directories containing applications and load in memory a list of avaliable applications accessible by current user.When afm-system-daemon installs or removes an application.On success it sends the signal org.AGL.afm.system.changed. When receiving such a signal, afm-user-daemon rebuilds its applications list.
afm-user-daemon provides the data it collects about applications to its clients.
afm-user-daemon launches application by using systemd. Systemd builds a secure environment for the application before starting it.
Once launched, running instances of application receive a run-id that identify them. To make interface with systemd evident, the pid is the run-id.
The command line tool afm-util uses dbus-send to send orders to afm-user-daemon. This small scripts allows to send command to afm-user-daemon either interactively at shell prompt or scriptically.


---- Widgets ----

widgets are ZIP files that can be signed and whose content is described by the file. There is no tool for unpacking a widget. For doing such operation, you can use thecommand unzip.
The command wgtpkg-info opens a widget file, reads its config.xml file and displays its content in a human readable way. To sign a widget, you need a private key and its certificate.
Packaging can be done using the command zip but we provide the tool wgtpkg-pack that may add checking.

The steps for writing a widget:
1.) make your application - 2.) create its configuration file config.xml 3.) sign it 4.)pack it

Applications can be installed in different places: the system itself, extension device. On a phone applications are typically installed on the sd card.
This translates to: •/usr/applications: system wide applications •/opt/applications: removable applications.
From here those paths are referenced as: "APPDIR".The main path for applications is: APPDIR/PKGID/VER, with PKGID: package id, VER:Version
All files are installed as user "afm" and group "afm". All files have rw(x) for user and r-(x) for group and others.This allows every user to read every file.

The file config.xml describes important data of the application to the framework:
•the unique identifier and name of the app •the type of the application •the icon of the application •the permissions linked to the application •the services and dependancies of the application
The file MUST be at the root of the widget and MUST be case sensitively name config.xml

The configuration file /etc/afm/afm-unit.conf defines how to create systemd units for widgets. 
Known types for the type of content are: 
•text/html: HTML application, content.src designates the home page of theapplication
•application/x-executable:   Native   application,   content.src   designates   therelative path of the binary
•application/vnd.agl.service: AGL service, content.src is not used.Adding more types is easy, it just need to edit the configuration file afm-unit.conf

The integration of the framework with systemd mainly consists of creating the systemd unit files corresponding to the need and requirements of the installed widgets. 
This configuration file named afm-unit.conf installed on the system with the path/etc/afm/afm-unit.conf describes how to generate all units from the config.xml configuration files of widgets. 



---- Overview AFB-Daemon-------

The name afb-daemon stands for Application Framework Binder Daemon ( = the binder).Afb-daemon is in charge to bind one instance of an application to the AGL frameworkand AGL system.
The binder afb-daemon serves multiple purposes:
1.) It acts as a gateway for the application to access the system	 2.)It acts as an HTTP server for serving files to HTML5 applications
3.) It allows HTML5 applications to have native extensions subject to security enforcement for accessing hardware resources or for speeding parts of algorithm

One of the most interesting aspect of using the binder afb-daemon is the ability to runapplications remotely. This feature is possible because the binder afb-daemonimplements native web protocols.


----Application example ---
C applications can use afb-daemon binder through a websocket connection.The library libafbwsc is provided for C clients that need to connect with an afb-daemon binder.
The program afb-client-demo is the C example that use libafbwsc library. Sourcecode is available here https://git.automotivelinux.org/src/app-framework-binder/plain/src/
Current implementation relies on libsystemd and file descriptors. This model might bereview in the future to support secure sockets and get rid of libsystemd dependency.
Applications communicate with their private binder(afb-daemon) using a network connection or potentially any other connection channel. While the current version does not yet implement Unix socket, this feature might be added in the near future.Developers need to be warned that HTTP protocol is a none connected protocol and that using HTTP socket connection to authenticate clients is not supported.For this reason, the binder should authenticate the application by using a shared secret. The secret is named "token" and the identification of client is named "session".The examples token-websock.qml  and  afb-client  are   demonstrating   how authentication and sessions are managed.

Exchanging tokens:
At application start, AGL framework communicates a shared secret to both binder andclient application. This initial secret is called the "initial token".
For each of its client application, the binder manages a current active token forsession management. This authentication token can be use to restrict the access to some binding's methods.
The token must be included in URI request on HTTP or during websockets connectionusing parameter token or x-afb-token.


Application for framework-binder: https://git.automotivelinux.org/src/app-framework-binder/plain/README.md
sources, software, libs etc.: https://git.automotivelinux.org/src/

later: agl-service-bluetooth unter: git clone "https://gerrit.automotivelinux.org/gerrit/apps/agl-service-bluetooth"

afb-daemon unter: git clone "https://gerrit.automotivelinux.org/gerrit/src/app-framework-binder" bzw. https://git.automotivelinux.org/src/app-framework-binder

libmicrohttpd: use the MHD_USE_ERROR_LOG option ---> Fehler beim Ausführen von ./configure liegt an den exportierten AGL-SDK-Umgebungsvariablen, neue Konsole öffnen und ausführen.
Nach "./configure", "make" und "sudo make install" kommt folgender output: 
 /bin/mkdir -p '/usr/local/lib'
 /bin/bash ../../libtool   --mode=install /usr/bin/install -c   libmicrohttpd.la '/usr/local/lib'
libtool: install: /usr/bin/install -c .libs/libmicrohttpd.so.12.56.0 /usr/local/lib/libmicrohttpd.so.12.56.0
libtool: install: (cd /usr/local/lib && { ln -s -f libmicrohttpd.so.12.56.0 libmicrohttpd.so.12 || { rm -f libmicrohttpd.so.12 && ln -s libmicrohttpd.so.12.56.0 libmicrohttpd.so.12; }; })
libtool: install: (cd /usr/local/lib && { ln -s -f libmicrohttpd.so.12.56.0 libmicrohttpd.so || { rm -f libmicrohttpd.so && ln -s libmicrohttpd.so.12.56.0 libmicrohttpd.so; }; })
libtool: install: /usr/bin/install -c .libs/libmicrohttpd.lai /usr/local/lib/libmicrohttpd.la
libtool: install: /usr/bin/install -c .libs/libmicrohttpd.a /usr/local/lib/libmicrohttpd.a
libtool: install: chmod 644 /usr/local/lib/libmicrohttpd.a
libtool: install: ranlib /usr/local/lib/libmicrohttpd.a
libtool: finish: PATH="/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/snap/bin:/sbin" ldconfig -n /usr/local/lib
----------------------------------------------------------------------
Libraries have been installed in:
   /usr/local/lib

If you ever happen to want to link against installed libraries
in a given directory, LIBDIR, you must either use libtool, and
specify the full pathname of the library, or use the '-LLIBDIR'
flag during linking and do at least one of the following:
   - add LIBDIR to the 'LD_LIBRARY_PATH' environment variable
     during execution
   - add LIBDIR to the 'LD_RUN_PATH' environment variable
     during linking
   - use the '-Wl,-rpath -Wl,LIBDIR' linker flag
   - have your system administrator add LIBDIR to '/etc/ld.so.conf'



in gleicher Konsole die Schritte für afb-daemon folgen:
sudo apt-get install libmagic-dev libjson-c-dev uuid-dev libsystemd-dev libssl-dev;
mkdir build; cd build;
cmake -DCMAKE_INSTALL_PREFIX=$HOME/local ..
make install
cd src
./afb-daemon --version

Test: .${AFB_DAEMON_DIR}/build/src/afb-daemon --help

zum starten via "afb-daemon" folgenden Befehl ausführen: sudo cp build/src/afb-daemon /usr/sbin

Test: 
$ AFB_DAEMON_DIR="/home/gast/Schreibtisch/agl_microservice/afb-daemon/app-framework-binder"
~/Schreibtisch/agl_microservice/afb-daemon/app-framework-binder$ afb-daemon --port=1234 --token='' --ldpaths=${AFB_DAEMON_DIR}/build --workdir=/tmp --rootdir=${AFB_DAEMON_DIR}/test


nun die Umgebungsvariablen sourcen, und tutorial compilieren mit Include des headers <afb/afb-binding.h>: gcc -fPIC -shared tuto-1.c -o tuto-1.so $(pkg-config --cflags-only-I afb-daemon) -I/home/gast/Schreibtisch/agl_microservice/sdk/sysroots/corei7-64-agl-linux/usr/include

for binding-writing:   app-framework-binder/docs/afb-binding-wiritng.md
https://github.com/iotbzh/webdocs-sample/blob/master/site/docs/architecture/en/dev/reference/ap/binder/afb-bindings-writing.md
http://old-docs.automotivelinux.org/docs/en/halibut/apis_services/reference/af-binder/afb-application-writing.html


zum Debuggen:
klappt nur mit AGL_DEVEL=ON, (in meinem Fall war das wohl standardmäßig auf OFF gestellt)
Example:

```bash
$ AFB_DEBUG_BREAK=main-entry AFB_DEBUG_WAIT=start-load,start-exec afb-daemon ....
```

This tells to ***afb-daemon*** to break at the point **main-entry** and to
wait at the points **start-load** and **start-exec**.

The items of the list can be separated using comma, space, tab or new-line.

The break/wait points are, in the order of their occurrence:

- main-entry: before decode arguments
- main-args: before daemon setup
- main-start: before starting jobs
- start-entry: before initialisation of sessions and hooks
- start-load: before load and pre-init of bindings
- start-start: before init of bindings
- start-http: before start of http server
- start-call: before execution of requests of the command line (option --call)
- start-exec: before execution of child preocees


< ldd: list dependencies shared libraries, *.so OR objdump -p ../app-framework-binder/build/src/afb-daemon >

auch bei Aufruf der vorinstallierten bindings tuto-1.so zB kommt der gleiche Fehler, also liegt nicht an meinem Programm
vergleiche Unterschied zu Deafult-testprogramm: app-framework-binder/build/bindings/tutorials/CMakeFiles/tuto-app1.dir


Richtiger Befehl:
(aus: https://gerrit.automotivelinux.org/gerrit/gitweb?p=src%2Fapp-framework-binder.git;hb=refs%2Fchanges%2F98%2F22198%2F5;f=docs%2Fafb-binding-writing.md)

~/Schreibtisch/agl_microservice/afb-daemon/selftest$ afb-daemon --binding ./binding-tut1.so --port=3333 --token='' 
ERROR: connection to events for httpd failed [/home/gast/Schreibtisch/agl_microservice/afb-daemon/app-framework-binder/src/afb-hsrv.c:461,afb_hsrv_start]
ERROR: starting of httpd failed [/home/gast/Schreibtisch/agl_microservice/afb-daemon/app-framework-binder/src/main-afb-daemon.c:396,start_http_server]

ich springe aus afb-main in afb-hsrv.c während http_init, genauer:
	if (!afb_hsrv_add_handler(hsrv, rootapi, afb_hswitch_websocket_switch, main_apiset, 20)) return 0;  ---> trifft nicht zu und ich lande in Zeile 388 von afb-main

danach land ich bei: init_http_server (hsrv=0x5555557ce320) at /home/gast/Schreibtisch/agl_microservice/afb-daemon/app-framework-binder/src/main-afb-daemon.c:323
dann: init_http_server (hsrv=0x5555557ce320) at /home/gast/Schreibtisch/agl_microservice/afb-daemon/app-framework-binder/src/main-afb-daemon.c:327

dann: start_http_server () at /home/gast/Schreibtisch/agl_microservice/afb-daemon/app-framework-binder/src/main-afb-daemon.c:394
nach paar Sprüngen angelangt bei: fdev_systemd_create (eloop=0x5555557ce900, fd=-1) at /home/gast/Schreibtisch/agl_microservice/afb-daemon/app-framework-binder/src/fdev-systemd.c:61

fdev_unref (fdev=0x5555557ceca0) at /home/gast/Schreibtisch/agl_microservice/afb-daemon/app-framework-binder/src/fdev.c:72

weiter gehts: fdev_systemd_create (eloop=0x5555557ce900, fd=<optimized out>) at /home/gast/Schreibtisch/agl_microservice/afb-daemon/app-framework-binder/src/fdev-systemd.c:72
afb_hsrv_start (hsrv=0x5555557ce320, connection_timeout=<optimized out>) at /home/gast/Schreibtisch/agl_microservice/afb-daemon/app-framework-binder/src/afb-hsrv.c:459 und in Zeile 461 ist dann finito

---> MHD_error log

normalerweise läuft main-afb in src/jobs über

normaler Verlauf: 
afb_args_parse (argc=6, argv=0x7fffffffc0f8) at /home/gast/Schreibtisch/agl_microservice/afb-daemon/app-framework-binder/src/afb-args.c:1068
main (argc=<optimized out>, argv=0x7fffffffc0f8) at /home/gast/Schreibtisch/agl_microservice/afb-daemon/app-framework-binder/src/main-afb-daemon.c:962
main (argc=<optimized out>, argv=0x7fffffffc0f8) at /home/gast/Schreibtisch/agl_microservice/afb-daemon/app-framework-binder/src/main-afb-daemon.c:986
jobs_start (allowed_count=3, start_count=0, waiter_count=100, start=0x5555555677c0 <start>, arg=0x0) at /home/gast/Schreibtisch/agl_microservice/afb-daemon/app-framework-binder/src/jobs.c:868


auch umschreiben der binding-tuto1.c datei hilft nicht, gleicher httpd fehler ---> evtl: 
gast@gast-pc:~/Schreibtisch/agl_microservice/afb-daemon/selftest$ sudo systemctl restart httpd
[sudo] Passwort für gast: 
Failed to restart httpd.service: Unit httpd.service not found.
gast@gast-pc:~/Schreibtisch/agl_microservice/afb-daemon/selftest$ ps aux | grep httpd
gast     17701  0.0  0.0  14788  1036 pts/1    S+   18:58   0:00 grep --color=auto httpd
gast@gast-pc:~/Schreibtisch/agl_microservice/afb-daemon/selftest$ sudo ps aux | grep httpd
gast     17708  0.0  0.0  14788  1100 pts/1    S+   18:58   0:00 grep --color=auto httpd
gast@gast-pc:~/Schreibtisch/agl_microservice/afb-daemon/selftest$ sudo systemctl restart apache2
Failed to restart apache2.service: Unit apache2.service not found.

auf dem CLoud-Laptop funktioniert anscheinend httpd, jedenfalls gibt es bei starten über 
~/Schreibtisch/agl_microservice/afb-daemon/selftest$ afb-daemon --binding ./binding-tut1.so --port=3333 --token=''

nach installieren von sudo apt-get install apache2 klappt es!

zum Nachschauen von afb Klassen, Funktionen usw.: 	https://docs.redpesk.bzh/docs/en/master/developer-guides/reference-v4/func-afb-event.html

afb-daemon --binding ./tuto-1.so --port 3333 --token ''
```

At this point, afb-daemon has started, it loaded the binding tuto-1.so and now
listen at localhost on the port 3333.

Testing using **curl**:

```bash
$ curl http://localhost:3333/api/tuto-1/hello
{"jtype":"afb-reply","request":{"status":"success","info":"hello world","uuid":"1e587b54-900b-49ab-9940-46141bc2e1d6"}}


die Verbindung klappt aber es wird nicht das richtige Programm ausgeführt. Ich mache mal mit tutorial2 weiter, evtl wird es mit der Zeit klarer!

tutorial2 funktioniert mit Verwendung von afb-client-demo in anderem terminal.
Terminal1:	afb-daemon --binding ./binding-tut2.so --port 3333 --token ''
Terminal2:./afb-client-demo -H localhost:3333/api?token=toto
binding-tut2 login {"user":"rolando","password":"please"}
ON-REPLY 1:  binding-tut2/login: OK
{
  "jtype":"afb-reply",
  "request":{
    "status":"success"
  }
}
binding-tut2 action {"subscribe": true}
ON-REPLY 2:binding-tut2/action: OK
{
  "response":{
    "subscribe":true
  },
  "jtype":"afb-reply",
  "request":{
    "status":"success"
  }
}

< zusätzlich in 3.terminal mit afb-client-demo aufgerufen und login/logut vollzogen: >
ON-EVENT binding-tut2/login:
{
  "event":"binding-tut2\/login",
  "data":"joboy",
  "jtype":"afb-event"
}
ON-EVENT binding-tut2/logout:
{
  "event":"binding-tut2\/logout",
  "data":"joboy",
  "jtype":"afb-event"
}


1.1.21
https://agl-gsod-2020-demo-mkdocs.readthedocs.io/en/latest/flounder/apis_services/reference/af-binder/afb-events-guide/
OR:	https://github.com/growupboron/AGL-GSoD-2020-Demo-MkDocs/tree/master/docs

Events: Signaling agents ( = bindings) are services that send events to any clients that are subscribed to receive it. The sent events carry any data.

Subscribing: the action that makes a client able to receive data from a signaling agent. Subscription must create resources for generating the data or deliver the data to the client.
When a client subscribes for data, the agent must:

    1.) Check that the subscription request is correct.
    2.) Establish the computation chain of the required data (if not already done).
    3.) Create a named event for the computed data (if not already done).
    4.) Ask the framework to establish the subscription to the event for the request.
    5.) Optionally give indications about the event in the reply to the client.

The framework only uses the event (not its name) for (un-)subscription and pushing and integrates libsystemd and its event loop. 
Within the framework, libsystemd is the standard API/library for bindings expecting to setup and handle I/O, timer or signal events.

Within the AGL framework, a signaling agent is a binding that has an API prefix. This prefix is meant to be unique and to identify the binding API. 
The names of the events that this signaling agent creates are automatically prefixed by the framework, using the API prefix of the binding.

The binder (afb-daemon, app. FW. binder-daemon) provides the way to connect applications to the services that it needs, but here daemon is not a background task.

A binding adds one API to the binder.An API is a set of verbs that can be called using either REST over HTTP or a kind of JSON RPC.
Bindings are either dynamically loaded libraries in the binder process or remote services running on the same/other host
When acting as an HTTP server, the binder treats the language settings of the HTTP requests to provide internationalized content as specified by widget specifications. - The APPLICATION

An application connects to the binder to get access to the API that it provides or to get its HTTP services to access resources.

5.1.:
Tic-tac-toe-example beginnen( refer: https://iot.bzh/download/public/2016/appfw/02_Documentation-AppFW-Core-2.0.pdf, https://github.com/iotbzh/webdocs-sample/blob/master/site/docs/architecture/en/dev/reference/ap/binder/afb-bindings-writing.md )

das tic-tac-toe-Binding funktioniert, die Argumenteneingabe muss evtl per JSON-format geschehen

tictactoe level {"boardid":"194","level":"3"}
ON-REPLY 3:tictactoe/level: OK
{
  "jtype":"afb-reply",
  "request":{
    "status":"success"
  }
}
ON-EVENT tictactoe/board:
{
  "event":"tictactoe\/board",
  "data":"level",
  "jtype":"afb-event"
}


mit zwei Clients:
tictactoe play
ON-REPLY 2:tictactoe/play: OK
{
  "response":{
    "boardid":194,
    "level":3,
    "board":[
      " ",
      " ",
      " ",
      "X",
      " ",
      " ",
      " ",
      "X",
      "O"
    ],
    "history":[
      7,
      8,
      3
    ]
  },
  "jtype":"afb-reply",
  "request":{
    "status":"success"
  }
}
ON-EVENT tictactoe/board:
{
  "event":"tictactoe\/board",
  "data":"play",
  "jtype":"afb-event"
}



tickets zum Durchstöbern:https://jira.automotivelinux.org/browse/

7.1.:
to do: wait in tictactoe einbauen und events einlesen --> wait klappt nicht, kein header-file für waiter-struct
events: hat zu tun mit subscribing und unsubscribing, sprich um Beanchrichtigungen wenn irgendwas geschehen sollte im Sinne einer verschickten Nachricht über das System etc.
https://agl-docs.readthedocs.io/en/master-ivory/4_APIs_and_Services/4.3_Application_Framework_Binder/4_Binder_events_guide/Binder_events_guide/

note: der binder (afb-daemon) verbindet ein binding (tictactoe) mit dem System/Applications, Afb-daemon is in charge to bind one instance of an application to the AGL frameworkand AGL system.


application framework daemons: afm-user-daemon  and  afm-system-daemon handle applications' life, they will manage operations like: install uninstall, run,suspend etc.
afm-system-daemon  and  afm-user-daemon  are launched as systemd services attached to system and user respectively. Normally, service files are located at
/lib/systemd/system/afm-system-daemon.service  and  /lib/systemd/user/afm-user-daemon.service

D-Bus is in charge of transmitting orders to the appropriate daemon depending upon D-Bus destination. The afm daemons take their orders from the session instance of D-Bus. 
The use of D-Bus is great because it allows to implement discovery and signaling.


8.1.
At start afm-user-daemon scans the directories containing applications and loads into memory a list of avaliable applications accessible by current user.
afm-user-daemon launches application by using systemd. Systemd builds a secure environment for the application before starting it.Once launched, running instances of application receive a runid that identify them. To make interfaces with systemd evident, the pid is the runid.
Un-/Installing applications: If the client own the right permissions,  afm-user-daemon  delegates that task to afm-system-daemon

The command line tool afm-util uses dbus-send to send orders to afm-user-daemon, example: afm-util install wgt (install the wgt file) •afm-util uninstall id (remove the installed widget of id)

writing a widget:
1.make your application		2.create its configuration file config.xml	3.sign it	4.pack it

Applications can be installed in different places: the system itself or extension device.On a phone application are typically installed on the sd card.
This translates to:	•/usr/applications: system wide applications	•/opt/applications: removable applications
From here those paths are referenced as: "APPDIR".The main path for applications is: APPDIR/PKGID/VER.
•APPDIR is as defined above
•PKGID is a directory whose name is the package identifier
•VER is the version of the package MAJOR.MINOR

All files are installed as user "afm" and group "afm". All files have rw(x) for user and r-(x) for group and others. The data of a user are in its directory and are labeled 
by the security-manager using the labels of the application

The file config.xml describes important data of the application to the framework:
•the unique identifier/name/type/icon of the application
•the permissions linked to the application and services and dependancies of the application

The file MUST be at the root of the widget and MUST be case sensitively name "config.xml"

The configuration file afm-unit.conf installed on the system with the path /etc/afm/afm-unit.conf describes how to generate all units from the config.xml configuration files of widgets. 

Next:
following sample application
only afm-system-daemon running as process on qemu, error when running selfinstalled widgets, but maybe example-widgets are too old.

write own widget:
helloworld-native-application depends on agl-service-helloworld (API
'helloworld') but it's not installed by default in AGL images. So, you must grab
it from here: https://git.automotivelinux.org/apps/agl-service-helloworld
and install it too.

When I tried to reproduce your issue, I also found a minor bug in
helloworld-native-application (mess up with log file). Please use my latest
commit from today:
https://github.com/iotbzh/helloworld-native-application/commit/fe2c9589d6018176b08af9afadb489f86d534091

So finally, it works as expected. Here's a capture of my test session:

Build the 2 widgets from an AGL docker container where SDK is installed:
-------------------------------------------------------
# . /xdt/sdk/environment-setup-aarch64-agl-linux
# git clone https://git.automotivelinux.org/apps/agl-service-helloworld
# agl-service-helloworld/autobuild/agl/autobuild package
# scp agl-service-helloworld/build/*.wgt root@h3ulcb:/tmp/
# git clone https://github.com/iotbzh/helloworld-native-application.git
# helloworld-native-application/autobuild/agl/autobuild package
# scp helloworld-native-application/build/*.wgt root@h3ulcb:/tmp/
-------------------------------------------------------

Then install on the board:
-------------------------------------------------------
$ ssh root@h3ulcb
root@h3ulcb:~# afm-util install /tmp/agl-service-helloworld.wgt
{
  "added":"agl-service-helloworld@1.0-7a5a796"
}
root@h3ulcb:~# afm-util install /tmp/helloworld-native-application.wgt
{
  "added":"helloworld-native-application@0.1-fe2c958"
}
-------------------------------------------------------

And finally run the native app, which calls the verb 'ping' on helloworld API
every 10s and appends the json result to a log file in /tmp.
-------------------------------------------------------
root@h3ulcb:~# afm-util start helloworld-native-application@0.1-fe2c958
8323
root@h3ulcb:~# tail -f /tmp/helloworld.log


last step: klonen von git clone --recursive https://github.com/iotbzh/helloworld-native-application.git

Änderung in helloworld-native-application.c 	von fprintf(fd,result) auf fprintf(fd,"%s", result);  jetzt klappt kompilieren
helloworld-native-application.wgt unter build, auf target-board kopieren und installieren.
Vor Ausführung aber unter liegendes service/binding installieren: https://git.automotivelinux.org/apps/agl-service-helloworld/tree/helloworld-skeleton/helloworld-service-binding.c?id=403c69ccf1b2696275c3f3409eac7df525a26dbc

or: helloworld_service.c im gleichen Ordner

gcc -fPIC -shared hello_world_service.c -o hello_world_service.so $(pkg-config --cflags-only-I afb-daemon) -I/home/gast/Schreibtisch/agl_microservice/sdk/sysroots/corei7-64-agl-linux/usr/include
afb-daemon --binding ./hello_world_service.so --port=3333 --token='' 


afb-client-demo -H localhost:3333/api?token=
helloworld
verb missing, bad line: 
helloworld ping
ON-REPLY 1:helloworld/ping: OK
{
  "response":0,
  "jtype":"afb-reply",
  "request":{
    "status":"success",
    "info":"Ping count = 0"
  }
}
helloworld ping
ON-REPLY 2:helloworld/ping: OK
{
  "response":1,
  "jtype":"afb-reply",
  "request":{
    "status":"success",
    "info":"Ping count = 1"
  }
}


------> hello_world_service  ping klappt, mit gleichem Ansatz das auf target-board kopieren und ausporbieren --> klappt auf target-board, obwohl Fehlermeldung erscheint.
Jetzt die Application zerlegen und in meine gewünschten App umformen!

13.1.
Beim selbstständigen kompilieren von helloworld-native-app.c treten Fehler folgender Art auf:
/home/gast/Schreibtisch/agl_microservice/sdk/sysroots/corei7-64-agl-linux/usr/include/afb/afb-wsj1.h:157: Warnung: undefinierter Verweis auf »afb_wsj1_reply_s«

gcc -Wall -g3  helloworld-native-application.c -o hello_world_service $(pkg-config --cflags-only-I afb-daemon) -I/home/gast/Schreibtisch/agl_microservice/sdk/sysroots/corei7-64-agl-linux/usr/include


Compile-Vorgang Schritt für Schritt durcharbeiten:
1.) Preprocessing is the first pass of any C compilation. It processes include-files, conditional compilation instructions and macros. ( das gibt keinen Fehler aus)
2.) Compilation is the second pass. It takes the output of the preprocessor, and the source code, and generates assembler source code. (erzeugt assembler-File, hellowroldapp.s ohne Fehler)
3.) Assembly is the third stage of compilation. It takes the assembly source code and produces an assembly listing with offsets. The assembler output is stored in an object file. 
( "gcc -Wall -g3 -c" führt zu einer kleinen Warnung aber keinen Fehler, output file helloworldapp.o)
4.) Linking is the final stage of compilation. It takes one or more object files or libraries as input and combines them to produce a single (usually executable) file. In doing so, it resolves references to external symbols, assigns final addresses to procedures/functions and variables, and revises code and data to reflect new addresses (a process called relocation).


Fehler: ld bedeutet dynamic library missing, mit "gcc -Wall -g3 helloworld_natapp.c -o helloworld_natapp -ljson-c -lsystemd" fallen Fehler zu json und sd-event schonmal raus
The binder provides a development library named libafbwsc (stands for lib AGL Framework Binder WebSocket Client). --> einbinden klappt nicht
ALSO: der Fehler liegt an lib afbwsc, die irgendwie nicht eingebunden werden kann obwohl extra manuell angegeben
eignetlich klappt es mit: gcc -Wall -g3 helloworld_natapp.c -o helloworld_natapp $(pkg-config --libs libafbwsc) -I/home/gast/Schreibtisch/agl_microservice/sdk/sysroots/corei7-64-agl-linux/usr/include


Jetzt das service und hello-world-native.c nachvollziehen, und service starten, mit afb-demo-client nachspielen!
Note: The program afb-client-demo is the C example that use libafbwsc library. Sourcecode is available here src/afb-client-demo.c

Build möglich mit:
gast@gast-pc:~/Schreibtisch/agl_microservice/afb-daemon/app-framework-binder$ export LIBRARY_PATH=/home/gast/local/lib/pkgconfig:/home/gast/local/lib:$LIBRARY_PATH
gast@gast-pc:~/Schreibtisch/agl_microservice/afb-daemon/app-framework-binder$ ldconfig
gast@gast-pc:~/Schreibtisch/agl_microservice/afb-daemon/app-framework-binder$ gcc -v -Wall -g3 helloworld_natapp.c -o helloworld_natapp $(pkg-config --cflags --libs afb-daemon libafbwsc) -I/home/gast/Schreibtisch/agl_microservice/sdk/sysroots/corei7-64-agl-linux/usr/include

neuer Fehler:
gast@gast-pc:~/Schreibtisch/agl_microservice/afb-daemon/app-framework-binder$ ./helloworld_natapp
./helloworld_natapp: error while loading shared libraries: libafbwsc.so.1: cannot open shared object file: No such file or directory

gast@gast-pc:~/Schreibtisch/agl_microservice/afb-daemon/app-framework-binder$ export LD_LIBRARY_PATH=/home/gast/local/lib:$LD_LIBRARY_PATH

gast@gast-pc:~/Schreibtisch/agl_microservice/afb-daemon/app-framework-binder$ ./helloworld_natapp
connection to 127.0.0.1:(null)/api?token=CLUTTER_IM_MODULE=xim failed: Invalid argument

Eeeeeees klaaaaaaaaaaaaaappppppppppt:
Terminal 1: 	afb-daemon --binding ./hello_world_service.so --port=1234 --token=''

Terminal 2:	gast@gast-pc:~/Schreibtisch/agl_microservice/afb-daemon/app-framework-binder$ ./helloworld_natapp 1234 ''

Und zum Test:	gast@gast-pc:~/Schreibtisch/agl_microservice/afb-daemon/app-framework-binder$ ls -ll /tmp
insgesamt 44
-rw------- 1 gast gast    0 Jan  1 13:25 config-err-LfBBOT
-rw-r--r-- 1 gast gast 1008 Jan 13 17:53 helloworld.log


14.1.
Debugging um Code besser zu verstehen:

			Breakpoint 1, main (ac=3, av=0x7fffffffc368, env=0x7fffffffc388) at helloworld_natapp.c:63
			63	{


			bei contiune bleibt code immer an "sd_event_run(loop, 30000000);" stehen

afb_ws_client_connect_wsj1 leads to:
gdb: 			afb_ws_client_connect_wsj1 (eloop=0x555555757290, uri=0x7fffffffc080 "127.0.0.1:1234/api?token=", itf=0x555555756010 <itf>, closure=0x0)
     			at /home/gast/Schreibtisch/agl_microservice/afb-daemon/app-framework-binder/src/afb-ws-client.c:318

leading to gdb:  	parse_uri (path=<optimized out>, service=<optimized out>, host=<optimized out>, uri=<optimized out>)
    			at /home/gast/Schreibtisch/agl_microservice/afb-daemon/app-framework-binder/src/afb-ws-client.c:268

und zurück:		main (ac=3, av=0x7fffffffc368, env=0x7fffffffc388) at helloworld_natapp.c:84
			(gdb) p wsj1
			$2 = (struct afb_wsj1 *) 0x5555557578d0

next:	create open logfile "fd = open (logFile, O_RDWR|O_CREAT, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH)"

dann:			(gdb) s
			call (api=0x555555555462 "helloworld", verb=0x555555555458 "ping", object=0x55555555545d "true") at helloworld_natapp.c:143

			(gdb) p wsj1
			$4 = (struct afb_wsj1 *) 0x5555557578d0
			(gdb) p *wsj1
			$5 = {refcount = 1, genid = 0, itf = 0x555555756010 <itf>, closure = 0x0, tokener = 0x555555757940, ws = 0x555555757df0, messages = 0x0, calls = 0x0, mutex = pthread_mutex_t = 				{Type = Normal, Status = Not acquired, Robust = No, Shared = No, Protocol = None}}


			(gdb) p itf
			$6 = {on_hangup = 0x0, on_call = 0x555555555134 <on_call>, on_event = 0x0}
			
			(gdb) s
			afb_wsj1_call_s (wsj1=0x5555557578d0, api=0x555555555462 "helloworld", verb=0x555555555458 "ping", object=0x55555555545d "true", on_reply=0x5555555551d2 <on_reply>, 				closure=0x555555757570)
    			at /home/gast/Schreibtisch/agl_microservice/afb-daemon/app-framework-binder/src/afb-wsj1.c:561

			(gdb) s
			wsj1_call_create (closure=<optimized out>, on_reply=<optimized out>, wsj1=<optimized out>) 
			at /home/gast/Schreibtisch/agl_microservice/afb-daemon/app-framework-binder/src/afb-wsj1.c:206

			(gdb) p tag
			$9 = 0x7fffffffbf50 "helloworld/ping"		[note: tag consists of API/verb]

			"make call":	(gdb) s
					wsj1_send_issot (i1=<optimized out>, t1=<optimized out>, wsj1=<optimized out>, o1=<optimized out>, s2=<optimized out>, s1=<optimized out>)
    					at /home/gast/Schreibtisch/agl_microservice/afb-daemon/app-framework-binder/src/afb-wsj1.c:530

			(gdb) s
			call (api=0x555555555462 "helloworld", verb=0x555555555458 "ping", object=0x55555555545d "true") at helloworld_natapp.c:153
			(gdb) p rc
			$12 = 0


			main (ac=3, av=0x7fffffffc368, env=0x7fffffffc388) at helloworld_natapp.c:98
			(gdb) s
			ON-REPLY 1:helloworld/ping: OK
			{
			  "response":5,
			  "jtype":"afb-reply",
			  "request":{
			    "status":"success",
			    "info":"Ping count = 5"
			  }
			}

			------------------------ inside event loop  (former /tmp/helloworld.log wasn't deleted hence the count starts at 5)--------



---> immer ON-Reply als Antwort. Evtl mal itf ändern, weil das als Argument mitgegeben wird in afb_ws_client ... ---> Fehler, achten auf richtige helloworld_natapp.c

Test with on_hangup

helloworld_natapp: /home/gast/Schreibtisch/agl_microservice/afb-daemon/app-framework-binder/src/afb-wsj1.c:98: afb_wsj1_create: Assertion `itf->on_call' failed.


example for html5-applications:
https://gerrit.automotivelinux.org/gerrit/gitweb?p=src/app-framework-demo.git;a=tree;f=afb-client
https://gerrit.automotivelinux.org/gerrit/gitweb?p=src/app-framework-demo.git;a=tree;f=afm-client

C applications can use afb-daemon binder through a websocket connection. The library libafbwsc is provided for C clients that need to connect with an afb-daemon binder.
The program afb-client-demo is the C example that uses the libafbwsc library. Current implementation relies on libsystemd and file descriptors.
(This model may be reviewed in the future to support secure sockets and get rid of libsystemd dependency )

Applications should understand sessions and token management when interacting with afb-daemon binder.
Applications communicate with their private binder (afb-daemon) using a network connection or any other potential connection channel.
While the current version does not yet implement Unix socket, this feature might be added in the near future.
Developers need to be warned that HTTP protocol to authenticate clients is not supported. For this reason, the binder should authenticate the application by using a shared secret.
The secret is named "token" and the identification of client is named "session.” The examples token-websock.qml and afb-client are demonstrating how authentication and sessions are managed.
At application start, AGL framework communicates a shared secret to both binder and client application. This initial secret is called the "initial token".

Example:
afb-daemon --port=1234 --token=123456 [...]

First, connects with the initial token, 123456:

$ curl http://localhost:1234/api/auth/connect?token=123456
{
  "jtype": "afb-reply",
  "request": {
     "status": "success",
     "token": "0aef6841-2ddd-436d-b961-ae78da3b5c5f",
     "uuid": "850c4594-1be1-4e9b-9fcc-38cc3e6ff015"
  },
  "response": {"token": "A New Token and Session Context Was Created"}
}

It returns an answer containing session UUID, 850c4594-1be1-4e9b-9fcc-38cc3e6ff015, and a refreshed token, 850c4594-1be1-4e9b-9fcc-38cc3e6ff015.

Check if session and token is valid:

$ curl http://localhost:1234/api/auth/check?token=0aef6841-2ddd-436d-b961-ae78da3b5c5f\&uuid=850c4594-1be1-4e9b-9fcc-38cc3e6ff015
{
  "jtype": "afb-reply",
  "request": {"status":"success"},
  "response": {"isvalid":true}
}

Replies use javascript object returned as serialized JSON.
This object contains at least 2 mandatory fields of name jtype and request and one optional field of name response, as seen above.
The field jtype must have a value of type string equal to "afb-reply".
The field request must have a value of type object.
This request object has at least one field named status and four optional fields named info, token, uuid, reqid.
This field response optionally contains an object returned when request succeeded.

Format of events:
Events are javascript object serialized as JSON.
Here is a template of event:
{
   "jtype": "afb-event",
   "event": "sample_api_name/sample_event_name",
   "data": ...any event data...
}


tictactoe hernehmen und so anpassen, dass zwei verschiedene Clients spielen können, das Feld jeweils im Display angezeigt wird. 
test über Start zwei verschiedener Qemu-Displays. Wenn das klappt, Richtung Talk-App gehen

18.1.:
gute Übersichtsfolien zu Bindings: http://events17.linuxfoundation.org/sites/events/files/slides/The%20State%20of%20AGL-%20Plumbing%20and%20Services.pdf

tic-tac-toe Spielfluss:
verb/function = 
new : start new game (setting board-id; resetting the game by memory-setting SPACE ' ' for every byte; setting number of moves to 0; 
					call function "changed" which is just executing afb_event_push(board->event, json_object_new_string(reason)) )

play : computer plays (checking first that state of game is not terminated; calling function "get_move" which returns the index of the move; 
			calling fct "add_move" which executes move on the board )

move: moving a piece (checking the state of the board, executing the move "add_move" )

board:	displaying the board ( calling function "describe" which returns the description as json-object format)

level:	setting the server level

join:	join a board

< für Compile: gcc -fPIC -shared -Wall -g3 tictactoe_self.c -o tictactoe_self.so $(pkg-config --cflags --libs afb-daemon libafbwsc) -I/home/gast/Schreibtisch/agl_microservice/sdk/sysroots/corei7-64-agl-linux/usr/include  //das -fPIC -shared gibt an, dass das source-file keine main-funktion hat ) 

die Funktion "changed" direkt mit dem Befehl afb_event_push(..) zu übersetzen gibt ein Fehler bezogen json_object aus

debugging am besten möglich über print-Befehle innerhalb der Funktion oder einfach "gdb --args afb-daemon ...." und als breakpoint den Funktionsnamen setzen.
Mit logging in file gdb_tictactoe-self.log via (gdb) set logging on

to do:
---> log-file durchlesen und nachvollziehen --- 
Fazit schonmal für verbs new und board:  Der Verlauf context_create, event_create, session-cookie erstellen und die Antworten afb-reply ähneln sich. 
Für "board" wird ein json-object zum Beschreiben des aktuellen Boards ( = Tafel) erstellt. in den Boards werden parameter wie id, Züge, usw. verewigt.

bloß tictactoe new triggert ein "ON-EVENT"

das verb "play" führt zum Ausführen eines Zugs über den Computer. Dabei ändert sich einiges in board (history, moves, usw.) und zwischendrin wird gecheckt ob jemand gewonnen hat.

zum Ausführen eines Zugs: tictactoe move {"index":"6"} wobei 6 den Ort des Kreuzchens angibt

zu guter letzt: verb "join" ( with id=none, special id for joinin new session) ----------> log-file anschauen, websocket-communication via websock.c mit websock_send_internal_v, ws_writev,
 sowie aws_writev und aws_readv in afb-ws.c 


---> in websockets, html,client <---> server, genauer einarbeiten und tictactoe so kürzen, dass zwei verschiedene Maschinen Nachrichten austauschen können

aus Doku:
Receiving the signals: 		Understanding what a client expects when it receives signals, events or data shall bethe most important topic of the designer of a signaling agent. The good point here isthat because JSON1 is the exchange format, structured data can be sent in a flexibleway.The good design is to allow as much as possible the client to describe what is neededwith the goal to optimize the processing to the requirements only.

Architectural digressions:	Based   on   their   dependencies   to   hardware,   signaling   agents   can   be   split   into   2categories: low-level signaling agents and high-level signaling agents.Low-level signaling agents are bound to the hardware and focused on interfacing anddriving.High-level signaling agent are independent of the hardware and focused on providingservice.This separation (that may in the corner look artificial) aim to help in the systemsdesign. The main idea here is that high-level signaling agents are providing “businesslogic”, also known as “application logic”, that is proper to the car industry and that canbe reused and that can evolve as a foundation for the future of the industry.

-----> tic-tac-toe.html genauer anschauen und ausführen!!


 
